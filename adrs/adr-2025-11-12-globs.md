# ADR 2025-11-12: Pattern-Based File Operations with Globs

**Date:** 2025-11-12
**Status:** Proposed
**Authors:** Discussion-driven design

## Context

Applications frequently need to copy multiple files based on pattern matching (glob patterns) while:
- Preserving or transforming directory structures
- Handling missing files gracefully (optional patterns)
- Setting appropriate file and directory permissions
- Performing operations efficiently at scale (thousands of files)

The motivating use case comes from XMLUI CLI's need to install demo applications by copying files from downloaded archives based on manifest-defined patterns. However, the solution should be generic and reusable across any Go project needing pattern-based file operations.

## Decision

Create a new `dt/dtglob` package as a separate module that provides:
1. Type-safe glob pattern representation
2. Rule-based file copying with destination mapping
3. Flexible permission handling via callback functions
4. Efficient batch operations

## Architecture

### Package Structure

**dt/dtglob** - Separate module (not in main dt package)
- **Reason:** Depends on `github.com/bmatcuk/doublestar/v4` for robust glob matching
- **Benefit:** Keeps core `dt` package minimal and dependency-free

### Layered Design

**Layer 1: dt package (primitives)**
```go
func (fp Filepath) CopyTo(destFile Filepath, opts *CopyOptions) error
func (fp Filepath) CopyToDir(destDir DirPath, opts *CopyOptions) error
```
Single file operations with permission control.

**Layer 2: dtglob package (patterns)**
```go
func (gr *GlobRule) CopyTo(baseDir, installDir DirPath, opts *CopyOptions) error
func (grs *GlobRules) CopyTo(installDir DirPath, opts *CopyOptions) error
```
Pattern-based operations on multiple files.

**Layer 3: Applications**
Application-specific logic, manifest parsing, user interaction.

## Core Types

### Glob

```go
type Glob string
```

A glob pattern string supporting wildcards:
- `*` - matches any characters except path separator
- `**` - matches any characters including path separators (recursive)
- `?` - matches single character
- `[abc]` - matches character class

**Examples:**
- `"*.go"` - all Go files in directory
- `"src/**/*.tsx"` - all TypeScript JSX files recursively under src/
- `"data.db"` - exact filename match

### GlobRule

```go
type GlobRule struct {
    From     Glob         // Pattern to match files
    To       dt.EntryPath // Destination (file or directory)
    Optional bool         // If true, no error when pattern matches nothing
}
```

Represents a single copy operation:
- **From**: Glob pattern relative to BaseDir
- **To**: Destination path relative to installDir
  - Ends with `/` → directory (preserves basename)
  - No trailing `/` → specific file path
- **Optional**: Skip rule if no files match (useful for optional components)

### GlobRules

```go
type GlobRules struct {
    BaseDir dt.DirPath  // Source directory containing files to match
    Rules   []GlobRule  // Ordered list of copy rules
}
```

Container for multiple rules sharing a common base directory.

## Key Design Decisions

### 1. Why Glob is Just a String

**Decision:** `type Glob string` (not a struct)

**Rationale:**
- Glob patterns are inherently strings
- No additional metadata needed at type level
- Lightweight and easy to construct
- Can be easily converted from JSON/config strings

### 2. Flexible Permission Handling

**Decision:** Use callback function instead of static modes

```go
type EntryModeFunc func(ep dt.EntryPath) os.FileMode

type CopyOptions struct {
    Force        bool
    DestModeFunc EntryModeFunc  // nil = preserve source permissions
}
```

**Rationale:**
- Different files may need different permissions (executables vs data files)
- Different directories may need different permissions
- Returning `0` allows fallback to source permissions per-file
- Single function handles both files and directories

**Rejected Alternatives:**
- Separate `FileMode` and `DirMode` fields - inflexible, can't vary per path
- `DryRun` and `Writer` in CopyOptions - application concerns, not primitive operations

**Example:**
```go
// Preserve source permissions (default)
fp.CopyTo(dest, nil)

// Set executables to 0755, others preserve source
fp.CopyTo(dest, &dt.CopyOptions{
    DestModeFunc: func(ep dt.EntryPath) os.FileMode {
        if ep.Contains("/bin/") {
            return 0755
        }
        return 0  // Preserve source
    },
})
```

### 3. Optional Flag Placement

**Decision:** `Optional` is a property of `GlobRule`, not `Glob`

**Rationale:**
- Whether missing files cause errors is a rule-level concern
- Same pattern might be optional in one context, required in another
- Aligns with manifest structure where optional is per-rule

### 4. EntryPath String Methods

**Decision:** Add convenience methods accepting flexible types

```go
func (ep EntryPath) HasSuffix(suffix dt.DirPath) bool
func (ep EntryPath) Contains(substr any) bool  // Type switch + panic on unknown
```

**Rationale for HasSuffix:**
- Primary use case: checking if `dt.EntryPath` begins with another path
- Another use case: checking for `/` (directory indicator)
- Semantically represents directory path, but string literal is convenient
- Always a `dt.DirPath` in practice

**Rationale for Contains:**
- Could check for any path component type
- Type switch supports: string, all dt path types, `fmt.Stringer`
- Panics on unsupported types _(fail fast during development)_

### 5. Destination Path Computation

**Decision:** Implicit stripping based on `**` position in pattern

Given:
```
Pattern:  "src/**/*.tsx"
Match:    "src/components/Button.tsx"
To:       "webroot/"
InstallDir: "/install"
```

Logic:
1. Split pattern on `**` → `["src/", "/*.tsx"]`
2. Strip prefix (`"src/"`) from match → `"components/Button.tsx"`
3. Join: `/install/webroot/components/Button.tsx`

**Rationale:**
- `**` naturally marks the "preserve structure from here" point
- Everything before `**` is the search root (to be stripped)
- Everything after `**` is the structure to preserve
- Intuitive for users familiar with glob patterns

## Helper Functions

### UnixModeFunc

```go
func UnixModeFunc(ep dt.EntryPath) os.FileMode {
    // Check if path exists and is a directory
    info, err := ep.Stat()
    if err == nil && info.IsDir() {
        return 0755  // rwxr-xr-x for directories
    }

    // Check if path ends with / (directory indicator)
    if ep.HasSuffix("/") {
        return 0755
    }

    // Default file mode
    return 0644  // rw-r--r-- for files
}
```

Provides standard Unix permissions (0755 for dirs, 0644 for files).

## Efficiency Considerations

### Directory Creation

**Optimization:** Create each unique destination directory only once

```go
func (grs *GlobRules) CopyTo(installDir dt.DirPath, opts *dt.CopyOptions) error {
    var errs []error

    // 1. Collect all unique destination directories
    dirs := grs.collectDestDirs(installDir)

    // 2. Create all directories once, collecting errors
    for _, dir := range dirs {
        err := dir.MkdirAll(mode)
        errs = dt.AppendErr(errs, err)
    }

    // 3. Copy all files (no MkdirAll per file)
    for _, rule := range grs.Rules {
        err := rule.CopyTo(grs.BaseDir, installDir, opts)
        if err != nil && !rule.Optional {
            errs = dt.AppendErr(errs, err)
        }
    }

    return dt.CombineErrs(errs)
}
```

**Benefit:** With 5000 files, create 50 directories instead of calling MkdirAll 5000 times.

**Error Handling:** Collects all errors using dt/dtoerr functionality and returns combined error.

## Usage Examples

### Example 1: Basic Copy with Preserved Permissions

```go
rules := &dtglob.GlobRules{
    BaseDir: "/tmp/extracted",
    Rules: []dtglob.GlobRule{
        {
            From: dtglob.Glob("client/**"),
            To:   "webroot/",
        },
    },
}

err := rules.CopyTo("/install", nil)
```

### Example 2: Multiple Rules with Optional Components

```go
rules := &dtglob.GlobRules{
    BaseDir: "/tmp/extracted",
    Rules: []dtglob.GlobRule{
        {
            From: dtglob.Glob("src/**/*.go"),
            To:   "app/",
        },
        {
            From: dtglob.Glob("config.json"),
            To:   "config/app.json",
        },
        {
            From:     dtglob.Glob("data.db"),
            To:       "data/",
            Optional: true,  // Don't fail if missing
        },
    },
}

err := rules.CopyTo("/install", &dt.CopyOptions{Force: true})
```

### Example 3: Custom Permission Function

```go
opts := &dt.CopyOptions{
    Force: true,
    DestModeFunc: func(ep dt.EntryPath) os.FileMode {
        // Executables get 0755
        if ep.Contains("/bin/") || ep.Contains("/scripts/") {
            return 0755
        }

        // Config files get restrictive permissions
        if ep.Contains("/config/") && !ep.HasSuffix("/") {
            return 0600
        }

        // Everything else preserves source
        return 0
    },
}

err := rules.CopyTo(installDir, opts)
```

### Example 4: Using UnixModeFunc Helper

```go
err := rules.CopyTo(installDir, &dt.CopyOptions{
    DestModeFunc: dt.UnixModeFunc,  // 0755 dirs, 0644 files
})
```

## Consequences

### Benefits

1. **Type Safety**: Distinct types for Glob, Filepath, DirPath prevent misuse
2. **Reusability**: Generic design works for any application needing glob-based operations
3. **Flexibility**: EntryModeFunc allows arbitrarily complex permission logic
4. **Efficiency**: Batch directory creation optimizes for large file sets
5. **Clarity**: Layered architecture separates concerns (primitives → patterns → apps)
6. **Robustness**: doublestar provides comprehensive glob support with security checks

### Trade-offs

1. **Complexity**: More layers and abstractions than simple file copy
2. **Learning Curve**: EntryModeFunc pattern requires understanding
3. **Dependency**: Separate module needed for doublestar
4. **No Built-in DryRun**: Applications must implement their own dry-run logic

## References

- [doublestar package](https://github.com/bmatcuk/doublestar)
- [glob pattern syntax](https://en.wikipedia.org/wiki/Glob_(programming))
- Unix file permissions: `man 2 chmod`
